{"version":3,"file":"useRealTimeProduction-CQYe6__r.js","sources":["../../src/hooks/useRealTimeProduction.js"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\nimport { useSocket } from './useSocket';\n\n/**\n * Hook para calcular produção em tempo real baseado no status da máquina\n * @param {Object} machine - Dados da máquina\n * @param {number} refreshInterval - Intervalo de atualização em ms (padrão: 1000ms)\n * @returns {Object} Dados de produção em tempo real\n */\nexport const useRealTimeProduction = (machine, refreshInterval = 1000) => {\n  const { socket } = useSocket();\n  const [realTimeData, setRealTimeData] = useState({\n    currentProduction: 0,\n    runningTime: 0,\n    efficiency: 0,\n    currentSpeed: 0,\n    isRunning: false\n  });\n  \n  const intervalRef = useRef(null);\n  const startTimeRef = useRef(null);\n  const lastStatusRef = useRef(null);\n  const accumulatedProductionRef = useRef(0);\n  const accumulatedRunningTimeRef = useRef(0);\n  const machineIdRef = useRef(null);\n  const lastCalculatedProductionRef = useRef(0);\n  const lastUpdateTimeRef = useRef(null);\n\n  // Função para obter chave do localStorage\n  const getStorageKey = (machineId) => `realtime_production_${machineId}`;\n\n  // Função para salvar dados no localStorage\n  const saveToStorage = (machineId, data) => {\n    try {\n      const storageData = {\n        ...data,\n        lastSaved: new Date().toISOString(),\n        shiftStart: getShiftStartTime().toISOString(),\n        lastCalculatedProduction: lastCalculatedProductionRef.current,\n        lastUpdateTime: lastUpdateTimeRef.current ? lastUpdateTimeRef.current.toISOString() : null\n      };\n      localStorage.setItem(getStorageKey(machineId), JSON.stringify(storageData));\n    } catch (error) {\n      console.warn('Erro ao salvar dados de produção:', error);\n    }\n  };\n\n  // Função para carregar dados do localStorage\n  const loadFromStorage = (machineId) => {\n    try {\n      const stored = localStorage.getItem(getStorageKey(machineId));\n      if (!stored) return null;\n      \n      const data = JSON.parse(stored);\n      const currentShiftStart = getShiftStartTime();\n      const storedShiftStart = new Date(data.shiftStart);\n      \n      // Verificar se ainda é o mesmo turno\n      if (currentShiftStart.getTime() === storedShiftStart.getTime()) {\n        return {\n          accumulatedProduction: data.accumulatedProduction || 0,\n          accumulatedRunningTime: data.accumulatedRunningTime || 0,\n          startTime: data.startTime ? new Date(data.startTime) : null,\n          lastStatus: data.lastStatus,\n          lastCalculatedProduction: data.lastCalculatedProduction || 0,\n          lastUpdateTime: data.lastUpdateTime ? new Date(data.lastUpdateTime) : null\n        };\n      } else {\n        // Turno mudou, limpar dados antigos\n        localStorage.removeItem(getStorageKey(machineId));\n        return null;\n      }\n    } catch (error) {\n      console.warn('Erro ao carregar dados de produção:', error);\n      return null;\n    }\n  };\n\n  // Função para calcular produção baseada no tempo decorrido\n  const calculateProduction = (timeInMinutes, speed) => {\n    // Retorna a produção calculada incrementalmente\n    return Math.max(0, Math.floor(timeInMinutes * speed));\n  };\n\n  // Função para calcular produção incremental (apenas o período atual)\n  const calculateIncrementalProduction = (elapsedMinutes, speed) => {\n    // Calcular apenas o incremento do período atual\n    return Math.max(0, Math.floor(elapsedMinutes * speed));\n  };\n\n  // Função para calcular produção de forma mais precisa (evita recálculos)\n  const calculateProductionIncrement = (currentTime, speed) => {\n    if (!lastUpdateTimeRef.current) {\n      lastUpdateTimeRef.current = currentTime;\n      return 0;\n    }\n    \n    const timeDiff = (currentTime - lastUpdateTimeRef.current) / 1000; // em segundos\n    \n    // Só calcula incremento se passou tempo suficiente (pelo menos 1 segundo)\n    if (timeDiff < 1) {\n      return 0;\n    }\n    \n    // Converter velocidade de batidas/minuto para batidas/segundo\n    const speedPerSecond = speed / 60;\n    const increment = timeDiff * speedPerSecond; // Incremento baseado em segundos\n    \n    // Sempre atualiza o tempo da última atualização\n    lastUpdateTimeRef.current = currentTime;\n    \n    // Garantir que o incremento seja sempre positivo\n    return Math.max(0, increment);\n  };\n\n  // Função para formatar tempo em horas e minutos\n  const formatTime = (minutes) => {\n    const hours = Math.floor(minutes / 60);\n    const mins = Math.floor(minutes % 60);\n    return `${hours}h ${mins}m`;\n  };\n\n  // Função para determinar se a máquina está funcionando\n  const isMachineRunning = (status) => {\n    return status === 'FUNCIONANDO' || status === 'RUNNING';\n  };\n\n  // Função para determinar se a máquina está fora de turno\n  const isMachineOffShift = (status) => {\n    return status === 'FORA_DE_TURNO' || status === 'OFF_SHIFT';\n  };\n\n  // Função para atualizar dados localmente (usado apenas como fallback)\n  const updateRealTimeDataLocal = useCallback(() => {\n    if (!machine || !machine.productionSpeed) {\n      return;\n    }\n    \n    const speed = machine.productionSpeed;\n\n    const now = new Date();\n    const isCurrentlyRunning = isMachineRunning(machine.status);\n    const isCurrentlyOffShift = isMachineOffShift(machine.status);\n    \n    // Se o status mudou, precisamos ajustar os cálculos\n    if (lastStatusRef.current !== machine.status) {\n      if (lastStatusRef.current && startTimeRef.current) {\n        // Calcular produção acumulada do período anterior\n        const wasRunning = isMachineRunning(lastStatusRef.current);\n        const wasOffShift = isMachineOffShift(lastStatusRef.current);\n        \n        // Só acumula tempo e produção se não estava fora de turno\n        if (wasRunning && !wasOffShift) {\n          const elapsedMinutes = (now - startTimeRef.current) / (1000 * 60);\n          // Acumular apenas a produção do período que acabou de terminar\n          const periodProduction = calculateIncrementalProduction(elapsedMinutes, speed);\n          accumulatedProductionRef.current += periodProduction;\n          // Garantir que a produção nunca diminua\n          accumulatedProductionRef.current = Math.max(accumulatedProductionRef.current, lastCalculatedProductionRef.current || 0);\n          lastCalculatedProductionRef.current = accumulatedProductionRef.current;\n          accumulatedRunningTimeRef.current += elapsedMinutes;\n        }\n      }\n      \n      // Resetar tempo de início para o novo status\n      startTimeRef.current = now;\n      lastStatusRef.current = machine.status;\n    }\n\n    // Se não há tempo de início, definir agora\n    if (!startTimeRef.current) {\n      startTimeRef.current = now;\n      lastStatusRef.current = machine.status;\n    }\n\n    // Calcular tempo decorrido desde a última mudança de status\n    const elapsedMinutes = (now - startTimeRef.current) / (1000 * 60);\n    \n    // Calcular produção atual usando incremento preciso\n    let currentProduction = accumulatedProductionRef.current;\n    let totalRunningTime = accumulatedRunningTimeRef.current;\n    \n    // Só calcula produção e tempo se estiver funcionando e não estiver fora de turno\n    if (isCurrentlyRunning && !isCurrentlyOffShift) {\n      // Calcular incremento de produção desde a última atualização\n      const productionIncrement = calculateProductionIncrement(now, speed);\n      \n      // Acumular o incremento de produção (sempre positivo)\n      if (productionIncrement > 0) {\n        accumulatedProductionRef.current += productionIncrement;\n        // Garantir que a produção nunca diminua\n        accumulatedProductionRef.current = Math.max(accumulatedProductionRef.current, lastCalculatedProductionRef.current || 0);\n        lastCalculatedProductionRef.current = accumulatedProductionRef.current;\n      }\n      \n      currentProduction = accumulatedProductionRef.current;\n      totalRunningTime += elapsedMinutes;\n    } else {\n      // Se não está funcionando, resetar o tempo da última atualização mas manter produção\n      lastUpdateTimeRef.current = null;\n      // Manter a produção acumulada mesmo quando parada\n      currentProduction = accumulatedProductionRef.current;\n    }\n\n    // Calcular eficiência baseada no tempo total do turno\n    const shiftStartTime = getShiftStartTime();\n    const totalShiftMinutes = (now - shiftStartTime) / (1000 * 60);\n    const efficiency = totalShiftMinutes > 0 ? Math.round((totalRunningTime / totalShiftMinutes) * 100) : 0;\n\n    // Calcular meta de produção para o turno (8 horas = 480 minutos)\n    const shiftDurationMinutes = 480; // 8 horas de turno\n    const targetProduction = speed * shiftDurationMinutes;\n\n    const newData = {\n      currentProduction: Math.max(0, currentProduction),\n      runningTime: totalRunningTime,\n      runningTimeFormatted: formatTime(totalRunningTime),\n      efficiency: Math.min(100, Math.max(0, efficiency)),\n      currentSpeed: isCurrentlyRunning ? speed : 0,\n      isRunning: isCurrentlyRunning,\n      targetProduction: targetProduction,\n      lastUpdate: now\n    };\n\n    setRealTimeData(newData);\n\n    // Salvar dados no localStorage\n    if (machine?.id) {\n      saveToStorage(machine.id, {\n        accumulatedProduction: accumulatedProductionRef.current,\n        accumulatedRunningTime: accumulatedRunningTimeRef.current,\n        startTime: startTimeRef.current?.toISOString(),\n        lastStatus: lastStatusRef.current\n      });\n    }\n  }, [machine]);\n\n  // Função para buscar dados de produção do servidor\n  const fetchProductionData = useCallback(async () => {\n    if (!machine?.id) {\n      return;\n    }\n\n    try {\n      const token = localStorage.getItem('token');\n      const response = await fetch(`/api/machines/${machine.id}/production/current-shift`, {\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n\n      if (response.ok) {\n        const result = await response.json();\n        if (result.success && result.data) {\n          const productionData = result.data;\n          \n          // Usar dados reais da API (shiftData) ao invés de cálculos locais\n          const newData = {\n            currentProduction: Math.max(0, productionData.estimatedProduction || 0),\n            runningTime: productionData.runningMinutes || 0,\n            runningTimeFormatted: formatTime(productionData.runningMinutes || 0),\n            efficiency: Math.min(100, Math.max(0, productionData.efficiency || 0)),\n            currentSpeed: isMachineRunning(machine.status) ? machine.productionSpeed : 0,\n            isRunning: isMachineRunning(machine.status),\n            targetProduction: machine.productionSpeed * 480, // 8 horas de turno\n            lastUpdate: new Date()\n          };\n\n          // Sincronizar dados locais com os dados da API\n          accumulatedProductionRef.current = productionData.estimatedProduction || 0;\n          accumulatedRunningTimeRef.current = productionData.runningMinutes || 0;\n          lastCalculatedProductionRef.current = productionData.estimatedProduction || 0;\n          \n          setRealTimeData(newData);\n          \n          // Salvar dados sincronizados no localStorage\n          if (machine?.id) {\n            saveToStorage(machine.id, {\n              accumulatedProduction: accumulatedProductionRef.current,\n              accumulatedRunningTime: accumulatedRunningTimeRef.current,\n              startTime: startTimeRef.current?.toISOString(),\n              lastStatus: lastStatusRef.current\n            });\n          }\n          \n          return; // Sucesso, não usar fallback\n        }\n      }\n    } catch (error) {\n      console.error('Erro ao buscar dados de produção:', error);\n    }\n    \n    // Fallback para cálculo local apenas em caso de erro na API\n    updateRealTimeDataLocal();\n  }, [machine?.id, machine?.status, machine?.productionSpeed, updateRealTimeDataLocal]);\n\n\n\n  // Função para obter o início do turno atual (alinhado com backend: 7h-19h)\n  const getShiftStartTime = () => {\n    const now = new Date();\n    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n    const hour = now.getHours();\n    \n    if (hour >= 7 && hour < 19) {\n      // Turno manhã: 07:00 - 19:00\n      return new Date(today.getTime() + 7 * 60 * 60 * 1000);\n    } else {\n      // Turno noite: 19:00 - 07:00\n      if (hour >= 19) {\n        return new Date(today.getTime() + 19 * 60 * 60 * 1000);\n      } else {\n        // Se for antes das 7h, é turno da noite que começou ontem às 19h\n        const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);\n        return new Date(yesterday.getTime() + 19 * 60 * 60 * 1000);\n      }\n    }\n  };\n\n  // Função para resetar dados (útil quando muda de turno)\n  const resetProduction = () => {\n    const now = new Date();\n    const hour = now.getHours();\n    \n    console.log(`🔄 Resetando produção às ${hour}:${now.getMinutes().toString().padStart(2, '0')}`);\n    \n    accumulatedProductionRef.current = 0;\n    accumulatedRunningTimeRef.current = 0;\n    startTimeRef.current = new Date();\n    lastStatusRef.current = machine?.status;\n    lastCalculatedProductionRef.current = 0;\n    lastUpdateTimeRef.current = null;\n    \n    // Limpar dados do localStorage\n    if (machine?.id) {\n      localStorage.removeItem(getStorageKey(machine.id));\n      console.log(`🗑️ Dados do localStorage limpos para máquina ${machine.id}`);\n    }\n    \n    // Atualizar estado para refletir o reset\n    setRealTimeData({\n      currentProduction: 0,\n      runningTime: 0,\n      efficiency: 0,\n      currentSpeed: 0,\n      isRunning: false\n    });\n  };\n\n  // Efeito para carregar dados salvos quando a máquina muda\n  useEffect(() => {\n    if (machine?.id && machine.id !== machineIdRef.current) {\n      machineIdRef.current = machine.id;\n      \n      // Carregar dados salvos do localStorage\n      const savedData = loadFromStorage(machine.id);\n      if (savedData) {\n        accumulatedProductionRef.current = savedData.accumulatedProduction;\n        accumulatedRunningTimeRef.current = savedData.accumulatedRunningTime;\n        startTimeRef.current = savedData.startTime;\n        lastStatusRef.current = savedData.lastStatus;\n        lastCalculatedProductionRef.current = savedData.lastCalculatedProduction || 0;\n        lastUpdateTimeRef.current = savedData.lastUpdateTime;\n      } else {\n        // Resetar se não há dados salvos\n        accumulatedProductionRef.current = 0;\n        accumulatedRunningTimeRef.current = 0;\n        startTimeRef.current = null;\n        lastStatusRef.current = null;\n        lastCalculatedProductionRef.current = 0;\n        lastUpdateTimeRef.current = null;\n      }\n    }\n  }, [machine?.id]);\n\n  // Efeito para iniciar/parar o timer\n  useEffect(() => {\n    if (!machine?.id) {\n      return;\n    }\n    \n    if (machine && machine.hasOwnProperty('productionSpeed')) {\n      // Buscar dados da API imediatamente\n      fetchProductionData();\n      \n      // Configurar intervalo para buscar dados da API (a cada 30 segundos)\n      // Reduzido para evitar sobrecarga já que priorizamos dados da API\n      intervalRef.current = setInterval(() => {\n        fetchProductionData();\n      }, 30000);\n      \n      return () => {\n        if (intervalRef.current) {\n          clearInterval(intervalRef.current);\n        }\n      };\n    }\n  }, [machine, fetchProductionData]);\n\n  // Efeito para detectar mudança de turno e resetar dados (alinhado com backend)\n  useEffect(() => {\n    const checkShiftChange = () => {\n      const now = new Date();\n      const hour = now.getHours();\n      const minute = now.getMinutes();\n      \n      // Resetar apenas nos horários de mudança de turno do backend (7h e 19h)\n      if ((hour === 7 || hour === 19) && minute >= 0 && minute <= 1) {\n        console.log(`🔄 Mudança de turno detectada às ${hour}:${minute.toString().padStart(2, '0')} - Resetando produção`);\n        resetProduction();\n      }\n    };\n\n    const shiftCheckInterval = setInterval(checkShiftChange, 30000); // Verificar a cada 30 segundos\n    \n    return () => clearInterval(shiftCheckInterval);\n  }, []);\n\n  // useEffect para escutar eventos WebSocket de mudança de status da máquina\n  useEffect(() => {\n    if (!socket || !machine?.id) return;\n\n    const handleMachineStatusChanged = (data) => {\n      // Verificar se o evento é para a máquina atual\n      if (data.machineId === machine.id) {\n        console.log('🔄 Status da máquina alterado via WebSocket:', data);\n        // Atualizar dados imediatamente quando o status mudar\n        fetchProductionData();\n      }\n    };\n\n    const handleProductionUpdate = (data) => {\n      if (data.machineId === machine.id) {\n        // Buscar dados atualizados da API quando houver atualização de produção\n        // Isso garante sincronização em tempo real com os dados do backend\n        fetchProductionData();\n      }\n    };\n\n    const handleOperationStarted = (data) => {\n      if (data.machineId === machine.id) {\n        console.log('🚀 Operação iniciada - atualizando produção:', data);\n        // Resetar dados de produção quando uma nova operação iniciar\n        resetProduction();\n        // Buscar dados atualizados\n        fetchProductionData();\n      }\n    };\n\n    const handleOperationEnded = (data) => {\n      if (data.machineId === machine.id) {\n        console.log('🛑 Operação finalizada - atualizando produção:', data);\n        // Buscar dados finais da operação\n        fetchProductionData();\n      }\n    };\n\n    socket.on('machine:status:changed', handleMachineStatusChanged);\n    socket.on('machine:operation-started', handleOperationStarted);\n    socket.on('machine:operation-ended', handleOperationEnded);\n    socket.on('production:update', handleProductionUpdate);\n\n    return () => {\n      socket.off('machine:status:changed', handleMachineStatusChanged);\n      socket.off('machine:operation-started', handleOperationStarted);\n      socket.off('machine:operation-ended', handleOperationEnded);\n      socket.off('production:update', handleProductionUpdate);\n    };\n  }, [socket, machine?.id, fetchProductionData, updateRealTimeDataLocal]);\n\n  return {\n    ...realTimeData,\n    resetProduction\n  };\n};\n\nexport default useRealTimeProduction;"],"names":["useRealTimeProduction","machine","refreshInterval","socket","useSocket","realTimeData","setRealTimeData","useState","intervalRef","useRef","startTimeRef","lastStatusRef","accumulatedProductionRef","accumulatedRunningTimeRef","machineIdRef","lastCalculatedProductionRef","lastUpdateTimeRef","getStorageKey","machineId","saveToStorage","data","storageData","getShiftStartTime","error","loadFromStorage","stored","currentShiftStart","storedShiftStart","calculateIncrementalProduction","elapsedMinutes","speed","calculateProductionIncrement","currentTime","timeDiff","speedPerSecond","increment","formatTime","minutes","hours","mins","isMachineRunning","status","isMachineOffShift","updateRealTimeDataLocal","useCallback","now","isCurrentlyRunning","isCurrentlyOffShift","wasRunning","wasOffShift","periodProduction","currentProduction","totalRunningTime","productionIncrement","shiftStartTime","totalShiftMinutes","efficiency","targetProduction","newData","_a","fetchProductionData","token","response","result","productionData","today","hour","yesterday","resetProduction","useEffect","savedData","shiftCheckInterval","minute","handleMachineStatusChanged","handleProductionUpdate","handleOperationStarted","handleOperationEnded"],"mappings":"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"}